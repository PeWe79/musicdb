// MusicDB,  a music manager with web-bases UI that focus on music.
// Copyright (C) 2017-2020  Ralf Stemmer <ralf.stemmer@gmx.net>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

"use strict";
/*
 *
 * This manager handled uploading data.
 *
 * When an upload gets started, an data ID is generated by this script.
 * Together with other meta data, an Upload-Request gets send to the MusicDB Server.
 * The server then requests chunks of the data.
 *
 * After a chunk of data is sent, a notification within a certain time gets expected by this upload manager.
 * This notification contains a state and request of the next chunk.
 *
 */

class UploadManager
{
    constructor()
    {
        this.uploads = new Object;
    }



    UploadFile(filedescription)
    {
        let reader = new FileReader();

        reader.onload = (event)=>
            {
                let contents = event.target.result;
                this.StartUpload(filedescription, new Uint8Array(contents));
            };
        reader.readAsArrayBuffer(filedescription);
    }



    async StartUpload(filedescription, rawdata)
    {
        
        // ! SHA-1 is used as ID and object key in the server and client because it is short.
        // Furthermore it is used to check if the upload was successful.
        // It is not, and never should be, used for security relevant tasks
        let checksum  = BufferToHexString(await crypto.subtle.digest("SHA-1", rawdata));
        let task      = new Object();
        task.id       = checksum;
        task.data     = rawdata;
        task.filesize = rawdata.length;
        task.offset   = 0;
        task.mimetype = filedescription.type;
        task.checksum = checksum;
        task.filename = filedescription.name
        this.uploads[task.id] = task;
        
        MusicDB_Call("InitiateUpload", 
            {
                uploadid: task.id,
                mimetype: task.mimetype,
                filesize: task.filesize,
                checksum: task.checksum,
                filename: task.filename
            });
        window.console && console.log(task);
    }


    UploadNextChunk(state)
    {
        window.console && console.log("UploadNextChunk");
        let uploadid  = state.uploadid;
        let task      = this.uploads[uploadid]
        let rawdata   = task.data.subarray(task["offset"], task["offset"] + state.chunksize)
        //let chunkdata = btoa(rawdata); // FIXME: Does not work. rawdata will be implicit converted to string
        let chunkdata = BufferToHexString(rawdata)
        task.offset  += rawdata.length;

        window.console && console.log(rawdata);
        window.console && console.log(chunkdata);
        window.console && console.log(task);
        MusicDB_Call("UploadChunk", {uploadid: uploadid, chunkdata: chunkdata});
    }



    onMusicDBNotification(fnc, sig, state)
    {
        if(fnc == "MusicDB:Upload" && sig == "ChunkRequest")
        {
            window.console && console.log(state);
            this.UploadNextChunk(state)
        }
        else if(fnc == "MusicDB:Upload" && sig == "UploadComplete")
        {
            window.console && console.log(state);
        }
    }



    onMusicDBMessage(fnc, sig, args, pass)
    {
        //if(fnc == "GetMDBState" && sig == "UpdateMDBState")
        //{
        //}

        return;
    }
}



// vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4

